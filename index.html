<html>

<head>
    <title>antibodysplash</title>
    <style>
        body {
            margin: 0;
        }

        canvas {
            width: 100vw;
            height: 100vh;
            display: block;
            background: rgb(255, 156, 145);
            background-size: cover;
            display: block;
        }
    </style>
</head>

<body>
    <script type="module">
        import * as THREE from './build/three.module.js';
        import { OrbitControls } from './examples/jsm/controls/OrbitControls.js';
        import { FBXLoader } from './examples/jsm/loaders/FBXLoader.js';
        import { RectAreaLightHelper } from './examples/jsm/helpers/RectAreaLightHelper.js';
        import { Reflector } from './examples/jsm/objects/Reflector.js';
        import { FirstPersonControls } from './examples/jsm/controls/FirstPersonControls.js';
        var WIDTH = window.innerWidth;
        var HEIGHT = window.innerHeight;
        var clock = new THREE.Clock();
        var renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(WIDTH, HEIGHT);
        var scene = new THREE.Scene();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 1000);
       // var camera = new THREE.Object3D();
        
        
        //camera.add(cam);
        //scene.add(camera);
        camera.position.set(10, 10, 5);
        //camera.lookAt(new THREE.Vector3(0, 0, 0));
        //var controls = new OrbitControls(camera, renderer.domElement);
        //controls.enableZoom = false;
        //controls.enablePan = false;
        var controls = new FirstPersonControls( camera, renderer.domElement );
				controls.movementSpeed = 0;
				controls.lookSpeed = 0.05;
                controls.constrainVertical=true;
                controls.verticalMax=Math.PI*0.555;
                controls.verticalMin=Math.PI*0.444;
                controls.heightSpeed = false;
                controls.heightMax = 0.6
                controls.heightMin = 0.3;
                

        var geometry = new THREE.BoxGeometry();
        var material = new THREE.MeshPhongMaterial({ color: 0xd6d6d6 });
        var cube = new THREE.Mesh(geometry, material);
        //var gridXZ = new THREE.GridHelper(10, 10, 0xff0000, 0xffffff);
        //scene.add(gridXZ);
        var loader = new FBXLoader();
        loader.load('models/fbx/myModel3.fbx', function (object) {
            object.scale.set(0.01, 0.01, 0.01);
            //var ac = new THREE.Mesh(object,material);
            object.traverse(function (object) {
                if (object.isMesh) {
                    const oldMat = object.material;
                    object.material = new THREE.MeshPhongMaterial({ color: 0xffffff, side: THREE.DoubleSide, shininess: 10.0 });

                }
            });
            //scene.add(object.children[3]);
            scene.add(object);
            scene.add(object.children[0].children[4]);
            object.children[0].children[0].material = new THREE.MeshPhongMaterial({ color: 0xff0000, emissive: 0x009686, emissiveIntensity: 0.1, specular: 0xffffff });
            object.children[0].children[3].material = new THREE.MeshStandardMaterial({ color: 0xffffff, transparent: true, opacity: 0.9 /*emissive:  0xffffff,  emissiveIntensity : 100*/ });
            //console.log(object.children[0]);
        });


        cube.position.set(2, 0, 0);
        //scene.add(cube);
        var width = 8;
        var height = 2;
        var intensity = 1;
        var rectLight = new THREE.RectAreaLight(0x486e62, intensity, width, height);
        rectLight.position.set(0, 5.2, 1);
        rectLight.lookAt(0, 0, 1);
        scene.add(rectLight)
        var tunnelLight2 = new THREE.PointLight(0x009686, 1.5, 40, 14);
        tunnelLight2.position.set(-1, 2.5, -1.5);
        scene.add(tunnelLight2);
        var tl = [];
        let amt = 20;
        var tcolor = new THREE.Color(0xff5040);
        var ncolor = new THREE.Color(0xfc5603);

        for (let i = 0; i < amt; i++) {
            tl[i] = new THREE.PointLight(tcolor, 2, 110, 20);
            tl[i].position.set(0, 1, -6 - (10.5 * i));
            tl[i].zval = tl[i].position.z;
            tl[i].ival = Math.random() * (1.5 - 0.8) + 0.8;
            scene.add(tl[i]);
        }

        /*
        var leftLight = new THREE.RectAreaLight(0xff5040, 2, 0.08, 2);
        leftLight.position.set(2.04, 1.5, 0.7);
        leftLight.lookAt(2.04, 1.5, -10);
        scene.add(leftLight);
        var rightLight = new THREE.RectAreaLight(0xff5040, 2, 0.08, 2);
        rightLight.position.set(-2.04, 1.5, 0.7);
        rightLight.lookAt(-2.04, 1.5, -10);
        scene.add(rightLight);
        */
        var pb = new THREE.PlaneBufferGeometry(300, 300);
        var groundMirror = new Reflector(pb, {
            clipBias: 0.003,
            textureWidth: WIDTH * window.devicePixelRatio,
            textureHeight: HEIGHT * window.devicePixelRatio,
            color: 0x009686
        });
        groundMirror.position.y = -0.7;
        groundMirror.rotateX(- Math.PI / 2);
        scene.add(groundMirror);

        var trackCurve = new THREE.CatmullRomCurve3([
            new THREE.Vector3(4.26, 1.17, 12.29),
            new THREE.Vector3(0.5, 1.05, 7.94),
            new THREE.Vector3(0, 1, 2.27),
            new THREE.Vector3(0, 1, -10),
            new THREE.Vector3(0, 1, -20),
            new THREE.Vector3(0, 1, -30),
            new THREE.Vector3(0, 1, -50),
            new THREE.Vector3(0, 1, -70)
        ], false, "centripetal");
        var trackPoints = trackCurve.getPoints(100);
        var trackGeo = new THREE.BufferGeometry().setFromPoints(trackPoints);
        var trackMat = new THREE.LineBasicMaterial({ color: 0xff0000 });
        var trackCObj = new THREE.Line(trackGeo, trackMat);

        //  scene.add(trackCObj);

        var camPosIndex = 0;

        var x = 0;
        var e = 0;
        document.addEventListener('wheel', (event) => {
            e = event.deltaY / 400;
            if (e < 0) {
                e *= 2;
            }
            x += e;
            x = THREE.MathUtils.clamp(x, 0, 67);
            // if (x < -20) {
            //     x = -20;
            // }


        });

        //controls.update();

        var animate = function () {
            requestAnimationFrame(animate);
            var timer = Date.now() * 0.005;
            for (let i = 0; i < amt; i++) {
                tl[i].position.y = 1 + (Math.sin((timer + (4 * i)) * 0.25) * 0.2);
                tl[i].position.x = (Math.cos((timer + (4 * i)) * 0.25) * 0.2);

                if (tl[i].position.z > -1) {
                    tl[i].position.z = -205.5;

                }
                else if (tl[i].position.z < -205.5) {
                    tl[i].position.z = -6;
                }
                else {
                    tl[i].position.z += e < 0 ? 0 : e * (((camPosIndex < 500 ? 1 : camPosIndex - 500) / 1000));
                }
                //tl[i].position.z = tl[i].zval + (x *(camPosIndex<0? 0:camPosIndex / 1000) ): tl[i].position.z = -6 - (10.5 * (amt-1));


                var mtimer = timer * 0.1;
                var abslfo = Math.abs(Math.cos(0.1 * timer + i));
                var vcolor = new THREE.Color(THREE.Math.lerp(tcolor.r, ncolor.r, abslfo), THREE.Math.lerp(tcolor.g, ncolor.g, abslfo), THREE.Math.lerp(tcolor.b, ncolor.b, abslfo));
                tl[i].color.set(vcolor);
                tl[i].intensity = tl[i].ival + (Math.cos(mtimer + i) * tl[i].ival * 0.85);
                // tl[i].intensity = i % 2 == 0 ? (1 + (Math.cos(timer * 0.1 * i + i) * 2)) : (1 + (Math.sin(timer * 0.1 * i + i) * 2));
            }
            tunnelLight2.intensity = 1.4 + (Math.cos(timer * 0.133) * 1);

            //camPosIndex = camPosIndex + 0.5;

            camPosIndex = THREE.MathUtils.lerp(camPosIndex, x * 15, 0.05);
            if (camPosIndex > 1000) {
                camPosIndex = 1000;
            }
            /*if (camPosIndex > 1000) {
                camPosIndex = 0;
            }*/
            //camPosIndex = Math.abs(camPosIndex);
            var camPos = trackCurve.getPoint(camPosIndex / 1000);
            var camRot = trackCurve.getTangent(camPosIndex / 1000);
             camera.position.x = camPos.x;
             camera.position.y = camPos.y;
             camera.position.z = camPos.z * (1 - ((camPosIndex<500?0:camPosIndex-500) / 1000));
            // console.log(camPosIndex,x);

            controls.update(clock.getDelta());
            // if (camPosIndex < 205) { camera.lookAt(0, 1.0, 0); }
           
            renderer.render(scene, camera);
        };
        animate();


    </script>
</body>


</div>


</html>